// Code generated by protoc-gen-go. DO NOT EDIT.
// source: es/es.proto

package es

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	timestamp "github.com/golang/protobuf/ptypes/timestamp"
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Aggregate_Format int32

const (
	Aggregate_PROTOBUF Aggregate_Format = 0
	Aggregate_JSON     Aggregate_Format = 1
	Aggregate_STRING   Aggregate_Format = 2
)

var Aggregate_Format_name = map[int32]string{
	0: "PROTOBUF",
	1: "JSON",
	2: "STRING",
}

var Aggregate_Format_value = map[string]int32{
	"PROTOBUF": 0,
	"JSON":     1,
	"STRING":   2,
}

func (x Aggregate_Format) String() string {
	return proto.EnumName(Aggregate_Format_name, int32(x))
}

func (Aggregate_Format) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_f14b94dd59679948, []int{2, 0}
}

// Message containing query parameters
type Query struct {
	Params               map[string]string `protobuf:"bytes,1,rep,name=params,proto3" json:"params,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Query) Reset()         { *m = Query{} }
func (m *Query) String() string { return proto.CompactTextString(m) }
func (*Query) ProtoMessage()    {}
func (*Query) Descriptor() ([]byte, []int) {
	return fileDescriptor_f14b94dd59679948, []int{0}
}

func (m *Query) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Query.Unmarshal(m, b)
}
func (m *Query) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Query.Marshal(b, m, deterministic)
}
func (m *Query) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Query.Merge(m, src)
}
func (m *Query) XXX_Size() int {
	return xxx_messageInfo_Query.Size(m)
}
func (m *Query) XXX_DiscardUnknown() {
	xxx_messageInfo_Query.DiscardUnknown(m)
}

var xxx_messageInfo_Query proto.InternalMessageInfo

func (m *Query) GetParams() map[string]string {
	if m != nil {
		return m.Params
	}
	return nil
}

// Message containing the event data
type Event struct {
	// Topic (name) of the event. These should be written in the past tense (snap_created)
	Topic string `protobuf:"bytes,1,opt,name=topic,proto3" json:"topic,omitempty"`
	// Aggregate to which the event refers to.
	Aggregate *Aggregate `protobuf:"bytes,2,opt,name=aggregate,proto3" json:"aggregate,omitempty"`
	// Priority of the event, where 0 is the highest priority.
	Priority int32 `protobuf:"varint,3,opt,name=priority,proto3" json:"priority,omitempty"`
	// Signature includes SHA1 signature computed against it's contents and signature of the previous event.
	Signature string `protobuf:"bytes,4,opt,name=signature,proto3" json:"signature,omitempty"`
	// Origin of the event. e.g. service name.
	OriginName string `protobuf:"bytes,5,opt,name=origin_name,json=originName,proto3" json:"origin_name,omitempty"`
	// Origin of the event. e.g. service ip address / browser.
	OriginIp string `protobuf:"bytes,6,opt,name=origin_ip,json=originIp,proto3" json:"origin_ip,omitempty"`
	// Metadata
	Metadata map[string]string `protobuf:"bytes,7,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Created has the identification of which service has created the event and
	// respective timestamp at which the event ocurred
	Created              *timestamp.Timestamp `protobuf:"bytes,8,opt,name=created,proto3" json:"created,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *Event) Reset()         { *m = Event{} }
func (m *Event) String() string { return proto.CompactTextString(m) }
func (*Event) ProtoMessage()    {}
func (*Event) Descriptor() ([]byte, []int) {
	return fileDescriptor_f14b94dd59679948, []int{1}
}

func (m *Event) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Event.Unmarshal(m, b)
}
func (m *Event) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Event.Marshal(b, m, deterministic)
}
func (m *Event) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Event.Merge(m, src)
}
func (m *Event) XXX_Size() int {
	return xxx_messageInfo_Event.Size(m)
}
func (m *Event) XXX_DiscardUnknown() {
	xxx_messageInfo_Event.DiscardUnknown(m)
}

var xxx_messageInfo_Event proto.InternalMessageInfo

func (m *Event) GetTopic() string {
	if m != nil {
		return m.Topic
	}
	return ""
}

func (m *Event) GetAggregate() *Aggregate {
	if m != nil {
		return m.Aggregate
	}
	return nil
}

func (m *Event) GetPriority() int32 {
	if m != nil {
		return m.Priority
	}
	return 0
}

func (m *Event) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *Event) GetOriginName() string {
	if m != nil {
		return m.OriginName
	}
	return ""
}

func (m *Event) GetOriginIp() string {
	if m != nil {
		return m.OriginIp
	}
	return ""
}

func (m *Event) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

func (m *Event) GetCreated() *timestamp.Timestamp {
	if m != nil {
		return m.Created
	}
	return nil
}

// Message containing the aggregate data.
type Aggregate struct {
	Id                   string            `protobuf:"bytes,1,opt,name=id,proto3" json:"id,omitempty"`
	Schema               string            `protobuf:"bytes,2,opt,name=schema,proto3" json:"schema,omitempty"`
	Version              int64             `protobuf:"varint,3,opt,name=version,proto3" json:"version,omitempty"`
	Format               Aggregate_Format  `protobuf:"varint,4,opt,name=format,proto3,enum=es.Aggregate_Format" json:"format,omitempty"`
	Data                 []byte            `protobuf:"bytes,5,opt,name=data,proto3" json:"data,omitempty"`
	Metadata             map[string]string `protobuf:"bytes,6,rep,name=metadata,proto3" json:"metadata,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *Aggregate) Reset()         { *m = Aggregate{} }
func (m *Aggregate) String() string { return proto.CompactTextString(m) }
func (*Aggregate) ProtoMessage()    {}
func (*Aggregate) Descriptor() ([]byte, []int) {
	return fileDescriptor_f14b94dd59679948, []int{2}
}

func (m *Aggregate) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Aggregate.Unmarshal(m, b)
}
func (m *Aggregate) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Aggregate.Marshal(b, m, deterministic)
}
func (m *Aggregate) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Aggregate.Merge(m, src)
}
func (m *Aggregate) XXX_Size() int {
	return xxx_messageInfo_Aggregate.Size(m)
}
func (m *Aggregate) XXX_DiscardUnknown() {
	xxx_messageInfo_Aggregate.DiscardUnknown(m)
}

var xxx_messageInfo_Aggregate proto.InternalMessageInfo

func (m *Aggregate) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Aggregate) GetSchema() string {
	if m != nil {
		return m.Schema
	}
	return ""
}

func (m *Aggregate) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Aggregate) GetFormat() Aggregate_Format {
	if m != nil {
		return m.Format
	}
	return Aggregate_PROTOBUF
}

func (m *Aggregate) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *Aggregate) GetMetadata() map[string]string {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// Message containing successfully event id
type Ack struct {
	Ok                   bool     `protobuf:"varint,1,opt,name=ok,proto3" json:"ok,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Ack) Reset()         { *m = Ack{} }
func (m *Ack) String() string { return proto.CompactTextString(m) }
func (*Ack) ProtoMessage()    {}
func (*Ack) Descriptor() ([]byte, []int) {
	return fileDescriptor_f14b94dd59679948, []int{3}
}

func (m *Ack) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Ack.Unmarshal(m, b)
}
func (m *Ack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Ack.Marshal(b, m, deterministic)
}
func (m *Ack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Ack.Merge(m, src)
}
func (m *Ack) XXX_Size() int {
	return xxx_messageInfo_Ack.Size(m)
}
func (m *Ack) XXX_DiscardUnknown() {
	xxx_messageInfo_Ack.DiscardUnknown(m)
}

var xxx_messageInfo_Ack proto.InternalMessageInfo

func (m *Ack) GetOk() bool {
	if m != nil {
		return m.Ok
	}
	return false
}

func init() {
	proto.RegisterEnum("es.Aggregate_Format", Aggregate_Format_name, Aggregate_Format_value)
	proto.RegisterType((*Query)(nil), "es.Query")
	proto.RegisterMapType((map[string]string)(nil), "es.Query.ParamsEntry")
	proto.RegisterType((*Event)(nil), "es.Event")
	proto.RegisterMapType((map[string]string)(nil), "es.Event.MetadataEntry")
	proto.RegisterType((*Aggregate)(nil), "es.Aggregate")
	proto.RegisterMapType((map[string]string)(nil), "es.Aggregate.MetadataEntry")
	proto.RegisterType((*Ack)(nil), "es.Ack")
}

func init() { proto.RegisterFile("es/es.proto", fileDescriptor_f14b94dd59679948) }

var fileDescriptor_f14b94dd59679948 = []byte{
	// 582 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x93, 0x4f, 0x4f, 0xdb, 0x4c,
	0x10, 0xc6, 0xb1, 0x93, 0x38, 0xce, 0x04, 0x50, 0x34, 0x82, 0xf7, 0xb5, 0x02, 0x2d, 0x51, 0x2e,
	0xa5, 0x2a, 0x38, 0x55, 0xa8, 0xd4, 0x7f, 0x27, 0x40, 0x80, 0xa8, 0x5a, 0xa0, 0x0e, 0x95, 0xaa,
	0x5e, 0xaa, 0x8d, 0xb3, 0x98, 0xad, 0xb1, 0xd7, 0xdd, 0x5d, 0x23, 0xe5, 0x73, 0xf5, 0x5b, 0xf5,
	0x53, 0x54, 0x1e, 0x3b, 0x21, 0x91, 0xda, 0x43, 0xd5, 0xdb, 0xcc, 0xf3, 0xcc, 0x8c, 0x77, 0x7f,
	0xb3, 0x86, 0x36, 0xd7, 0x03, 0xae, 0xfd, 0x4c, 0x49, 0x23, 0xd1, 0xe6, 0xba, 0xbb, 0x13, 0x49,
	0x19, 0xdd, 0xf1, 0x01, 0x29, 0xe3, 0xfc, 0x66, 0x60, 0x44, 0xc2, 0xb5, 0x61, 0x49, 0x56, 0x16,
	0xf5, 0xbf, 0x43, 0xe3, 0x63, 0xce, 0xd5, 0x14, 0xf7, 0xc1, 0xc9, 0x98, 0x62, 0x89, 0xf6, 0xac,
	0x5e, 0x6d, 0xb7, 0x3d, 0xdc, 0xf4, 0xb9, 0xf6, 0xc9, 0xf2, 0xaf, 0x48, 0x3f, 0x49, 0x8d, 0x9a,
	0x06, 0x55, 0x51, 0xf7, 0x35, 0xb4, 0x17, 0x64, 0xec, 0x40, 0x2d, 0xe6, 0x53, 0xcf, 0xea, 0x59,
	0xbb, 0xad, 0xa0, 0x08, 0x71, 0x03, 0x1a, 0xf7, 0xec, 0x2e, 0xe7, 0x9e, 0x4d, 0x5a, 0x99, 0xbc,
	0xb1, 0x5f, 0x59, 0xfd, 0x9f, 0x36, 0x34, 0x4e, 0xee, 0x79, 0x6a, 0x8a, 0x1a, 0x23, 0x33, 0x11,
	0x56, 0x7d, 0x65, 0x82, 0xcf, 0xa0, 0xc5, 0xa2, 0x48, 0xf1, 0x88, 0x99, 0xb2, 0xbb, 0x3d, 0x5c,
	0x2b, 0x0e, 0x73, 0x38, 0x13, 0x83, 0x07, 0x1f, 0xbb, 0xe0, 0x66, 0x4a, 0x48, 0x25, 0xcc, 0xd4,
	0xab, 0xf5, 0xac, 0xdd, 0x46, 0x30, 0xcf, 0x71, 0x1b, 0x5a, 0x5a, 0x44, 0x29, 0x33, 0xb9, 0xe2,
	0x5e, 0x9d, 0x3e, 0xf1, 0x20, 0xe0, 0x0e, 0xb4, 0xa5, 0x12, 0x91, 0x48, 0xbf, 0xa6, 0x2c, 0xe1,
	0x5e, 0x83, 0x7c, 0x28, 0xa5, 0x0b, 0x96, 0x70, 0xdc, 0x82, 0x56, 0x55, 0x20, 0x32, 0xcf, 0x21,
	0xdb, 0x2d, 0x85, 0xf3, 0x0c, 0x0f, 0xc0, 0x4d, 0xb8, 0x61, 0x13, 0x66, 0x98, 0xd7, 0x24, 0x60,
	0xff, 0x17, 0x67, 0xa4, 0x7b, 0xf9, 0x1f, 0x2a, 0xa7, 0x44, 0x36, 0x2f, 0xc4, 0x17, 0xd0, 0x0c,
	0x15, 0x67, 0x86, 0x4f, 0x3c, 0x97, 0xee, 0xd5, 0xf5, 0xcb, 0xfd, 0xf8, 0xb3, 0xfd, 0xf8, 0xd7,
	0xb3, 0xfd, 0x04, 0xb3, 0xd2, 0xee, 0x5b, 0x58, 0x5b, 0x1a, 0xf8, 0x57, 0xb0, 0x7f, 0xd8, 0xd0,
	0x9a, 0x83, 0xc3, 0x75, 0xb0, 0xc5, 0xa4, 0x6a, 0xb4, 0xc5, 0x04, 0xff, 0x03, 0x47, 0x87, 0xb7,
	0x3c, 0x61, 0x55, 0x63, 0x95, 0xa1, 0x07, 0xcd, 0x7b, 0xae, 0xb4, 0x90, 0x29, 0x41, 0xad, 0x05,
	0xb3, 0x14, 0xf7, 0xc0, 0xb9, 0x91, 0x2a, 0x61, 0x86, 0x80, 0xae, 0x0f, 0x37, 0x96, 0x36, 0xe3,
	0x9f, 0x92, 0x17, 0x54, 0x35, 0x88, 0x50, 0x27, 0x42, 0x05, 0xdc, 0xd5, 0x80, 0x62, 0x7c, 0xb9,
	0x40, 0xce, 0x21, 0x72, 0x5b, 0xcb, 0x33, 0xfe, 0x40, 0xef, 0xdf, 0x38, 0xec, 0x81, 0x53, 0x9e,
	0x0d, 0x57, 0xc1, 0xbd, 0x0a, 0x2e, 0xaf, 0x2f, 0x8f, 0x3e, 0x9d, 0x76, 0x56, 0xd0, 0x85, 0xfa,
	0xbb, 0xd1, 0xe5, 0x45, 0xc7, 0x42, 0x00, 0x67, 0x74, 0x1d, 0x9c, 0x5f, 0x9c, 0x75, 0xec, 0xfe,
	0x26, 0xd4, 0x0e, 0xc3, 0xb8, 0xc0, 0x25, 0x63, 0x9a, 0xef, 0x06, 0xb6, 0x8c, 0x87, 0x01, 0x20,
	0x2d, 0x78, 0x24, 0x73, 0x15, 0xf2, 0x63, 0x99, 0x24, 0x2c, 0x9d, 0xe0, 0x63, 0x70, 0x8e, 0x69,
	0x55, 0xd8, 0x9a, 0x3f, 0x81, 0x6e, 0x93, 0xee, 0x14, 0xc6, 0xfd, 0x15, 0xdc, 0x86, 0xfa, 0x28,
	0x65, 0xd9, 0xef, 0xdd, 0xe1, 0x67, 0xd8, 0x5c, 0x98, 0x79, 0xa5, 0xe4, 0x37, 0x1e, 0x9a, 0x82,
	0xf4, 0x23, 0xa8, 0x9d, 0x71, 0xb3, 0xd8, 0xf5, 0x10, 0xf6, 0x57, 0xb0, 0x07, 0xf5, 0xf7, 0x42,
	0x57, 0x3e, 0xfd, 0xa7, 0x4b, 0xfe, 0x73, 0xeb, 0xe8, 0xe9, 0x97, 0x27, 0x91, 0x30, 0xb7, 0xf9,
	0xd8, 0x0f, 0x65, 0x32, 0x60, 0x79, 0x3c, 0x16, 0x66, 0xc0, 0x0b, 0x7b, 0x5f, 0xd3, 0xc7, 0xf6,
	0xe9, 0xd5, 0x0d, 0xb8, 0x1e, 0x3b, 0x14, 0x1d, 0xfc, 0x0a, 0x00, 0x00, 0xff, 0xff, 0x88, 0x7f,
	0x35, 0xfb, 0x40, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// EventSourceCommandClient is the client API for EventSourceCommand service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EventSourceCommandClient interface {
	Create(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Ack, error)
	Snap(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Ack, error)
}

type eventSourceCommandClient struct {
	cc *grpc.ClientConn
}

func NewEventSourceCommandClient(cc *grpc.ClientConn) EventSourceCommandClient {
	return &eventSourceCommandClient{cc}
}

func (c *eventSourceCommandClient) Create(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, "/es.EventSourceCommand/Create", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventSourceCommandClient) Snap(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Ack, error) {
	out := new(Ack)
	err := c.cc.Invoke(ctx, "/es.EventSourceCommand/Snap", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// EventSourceCommandServer is the server API for EventSourceCommand service.
type EventSourceCommandServer interface {
	Create(context.Context, *Event) (*Ack, error)
	Snap(context.Context, *Event) (*Ack, error)
}

func RegisterEventSourceCommandServer(s *grpc.Server, srv EventSourceCommandServer) {
	s.RegisterService(&_EventSourceCommand_serviceDesc, srv)
}

func _EventSourceCommand_Create_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventSourceCommandServer).Create(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/es.EventSourceCommand/Create",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventSourceCommandServer).Create(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventSourceCommand_Snap_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventSourceCommandServer).Snap(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/es.EventSourceCommand/Snap",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventSourceCommandServer).Snap(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

var _EventSourceCommand_serviceDesc = grpc.ServiceDesc{
	ServiceName: "es.EventSourceCommand",
	HandlerType: (*EventSourceCommandServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Create",
			Handler:    _EventSourceCommand_Create_Handler,
		},
		{
			MethodName: "Snap",
			Handler:    _EventSourceCommand_Snap_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "es/es.proto",
}

// EventSourceProjectionClient is the client API for EventSourceProjection service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type EventSourceProjectionClient interface {
	Get(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error)
	List(ctx context.Context, in *Query, opts ...grpc.CallOption) (EventSourceProjection_ListClient, error)
}

type eventSourceProjectionClient struct {
	cc *grpc.ClientConn
}

func NewEventSourceProjectionClient(cc *grpc.ClientConn) EventSourceProjectionClient {
	return &eventSourceProjectionClient{cc}
}

func (c *eventSourceProjectionClient) Get(ctx context.Context, in *Event, opts ...grpc.CallOption) (*Event, error) {
	out := new(Event)
	err := c.cc.Invoke(ctx, "/es.EventSourceProjection/Get", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventSourceProjectionClient) List(ctx context.Context, in *Query, opts ...grpc.CallOption) (EventSourceProjection_ListClient, error) {
	stream, err := c.cc.NewStream(ctx, &_EventSourceProjection_serviceDesc.Streams[0], "/es.EventSourceProjection/List", opts...)
	if err != nil {
		return nil, err
	}
	x := &eventSourceProjectionListClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type EventSourceProjection_ListClient interface {
	Recv() (*Event, error)
	grpc.ClientStream
}

type eventSourceProjectionListClient struct {
	grpc.ClientStream
}

func (x *eventSourceProjectionListClient) Recv() (*Event, error) {
	m := new(Event)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// EventSourceProjectionServer is the server API for EventSourceProjection service.
type EventSourceProjectionServer interface {
	Get(context.Context, *Event) (*Event, error)
	List(*Query, EventSourceProjection_ListServer) error
}

func RegisterEventSourceProjectionServer(s *grpc.Server, srv EventSourceProjectionServer) {
	s.RegisterService(&_EventSourceProjection_serviceDesc, srv)
}

func _EventSourceProjection_Get_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Event)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventSourceProjectionServer).Get(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/es.EventSourceProjection/Get",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventSourceProjectionServer).Get(ctx, req.(*Event))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventSourceProjection_List_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Query)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventSourceProjectionServer).List(m, &eventSourceProjectionListServer{stream})
}

type EventSourceProjection_ListServer interface {
	Send(*Event) error
	grpc.ServerStream
}

type eventSourceProjectionListServer struct {
	grpc.ServerStream
}

func (x *eventSourceProjectionListServer) Send(m *Event) error {
	return x.ServerStream.SendMsg(m)
}

var _EventSourceProjection_serviceDesc = grpc.ServiceDesc{
	ServiceName: "es.EventSourceProjection",
	HandlerType: (*EventSourceProjectionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Get",
			Handler:    _EventSourceProjection_Get_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "List",
			Handler:       _EventSourceProjection_List_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "es/es.proto",
}
